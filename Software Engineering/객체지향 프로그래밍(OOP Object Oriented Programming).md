# 객체지향 프로그래밍(OOP: Object Oriented Programming)

#### 개요: 이전의 패러다임

1. 순차적, 비구조적 프로그래밍

   - 가장 초기 코딩 패러다임

   - 코드를 순서대로 읽는다: 코드의 흐름, 순서에 기반하는 프로그래밍

   - "구조"라는 개념은 없음 -> `goto`문 사용. 

     > goto
     > 어느 부분에서 레이블이나 행번호가 있는 다른 부분으로 건너뛸 때 사용하는 명령어.
     >
     > 즉, 이전에 작성했던 코드가 다시 필요하면 그 곳으로 이동.

   - `goto`문이 무분별하게 사용하면 논리 흐름을 파악하기 어려워짐. (위로 올라갔다~ 다시 아래로 갔다가~ 다시 또 위로 갔다가..) -> goto 사용을 지양

   <img src="https://user-images.githubusercontent.com/71415474/116349499-1ab40e80-a82b-11eb-809c-8bc4cd0f1fae.png" alt="객체지향프로그래밍_0" style="zoom:80%;" />

2. 절차적, 구조적 프로그래밍

   - 절차적 프로그래밍의 "절차"란 프로시저를 의미.

     > 프로시저
     >
     > 반환값이 없고 실행이 주가 되는 함수. (ex. printf)

   - 반복될 가능성이 있는 것들을 재사용이 가능한 함수(프로시저)로 만들어 사용.

   - 프로시저가 중복될 경우 반복문으로 구성

   - 유지보수와 디버깅이 어렵고, 실행순서가 있기 때문에 순서가 바뀌면 동일한 결과를 보장하기 어렵다.

   

   <img src="https://user-images.githubusercontent.com/71415474/116349997-25bb6e80-a82c-11eb-8948-9a0a6de01b4c.png" alt="객체지향프로그래밍_2" style="zoom:80%;" />

   

---

### 객체지향 프로그래밍

특정한 개념의 함수와 자료형을 함께 묶어서 관리하는 프로그래밍

- 객체 내부에 자료형(필드)와 함수(메서드)가 같이 존재
- 객체 간의 독립성이 생김.
- 중복코드의 양이 감소
- 독립성이 확립되면 유지보수에 좋음

<br>

<img src="https://user-images.githubusercontent.com/71415474/116350078-47b4f100-a82c-11eb-9949-99c5dde7d1fc.png" alt="객체지향프로그래밍_3" style="zoom:80%;" />

![객체지향프로그래밍_4](https://user-images.githubusercontent.com/71415474/116350158-661aec80-a82c-11eb-8d9c-acd240af906f.png)

<br>

#### 장단점

**장점**

1. **재사용성**

상속을 통해 프로그래밍시 코드의 재사용을 높일 수 있습니다.

2. **생산성 향상**

잘 설계된 클래스를 만들어서 독립적인 객체를 사용함으로써 개발의 생산성을 향상시킵니다.

3. **자연적인 모델링**

우리 일상생활의 모습의 구조가 객체에 자연스럽게 녹아들어 있기 때문에 생각하고 있는 것을 그대로 자연스럽게 구현할 수 있습니다.

4. **유지보수의 우수성**

프로그램 추가, 수정을 하더라도 캡슐화를 통해 주변 영향이 적기때문에 유지보수가 쉽습니다.

<br>

**단점**

1. **개발속도가 느림**

객체가 처리하려는 것에 대한 정확한 이해가 필요하기에 설계단계부터 많은 시간이 소요됩니다.

2. **실행속도가 느림**

객체지향언어는 대체적으로 실행속도가 느립니다.

3. **코딩난이도 상승**

다중 상속이 지원되는 C++ 같은 경우에 너무 복잡해져 코딩의 난이도가 상승합니다.

<br>

#### 특징

<br>

1. ##### 추상화(Abstraction)

   > 필요로 하는 속성이나 행동을 추출하는 작업

   추상적인 개념에 의존하여 설계해야 유연함을 갖출 수 있다.

   즉, 세부적인 사물들의 공통적인 특징을 파악한 후 하나의 집합으로 만들어내는 것이 추상화.

   ```
   ex. 아우디, BMW, 벤츠는 모두 '자동차'라는 공통점이 있다.
   
   자동차라는 추상화 집합을 만들어두고, 자동차들이 가진 공통적인 특징들을 만들어 활용한다.
   ```

   ***'왜 필요하죠?'***

   예를 들면, '현대'와 같은 다른 자동차 브랜드가 추가될 수도 있다. 이때 추상화로 구현해두면 다른 곳의 코드는 수정할 필요 없이 추가로 만들 부분만 새로 생성해주면 된다.

   <br>

2. ##### 캡슐화(Encapsulation)

   > 필요한 속성(Attribute)와 행위(Method)를 하나로 묶고 실제 구현 내용을 감추는 것
   >
   > 낮은 결합도를 유지할 수 있도록 설계하는 것

   쉽게 말하면, **한 곳에서 변화가 일어나도 다른 곳에 미치는 영향을 최소화 시키는 것**을 말한다.

   (객체가 내부적으로 기능을 어떻게 구현하는지 감추는 것!)

   결합도가 낮도록 만들어야 하는 이유가 무엇일까? **결합도(coupling)란, 어떤 기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인가를 나타내는 말**이다.

   즉, 독립적으로 만들어진 객체들 간의 의존도가 최대한 낮게 만드는 것이 중요하다. 객체들 간의 의존도가 높아지면 굳이 객체 지향으로 설계하는 의미가 없어진다.

   우리는 소프트웨어 공학에서 **객체 안의 모듈 간의 요소가 밀접한 관련이 있는 것으로 구성하여 응집도를 높이고 결합도를 줄여야 요구사항 변경에 대처하는 좋은 설계 방법**이라고 배운다.

   > 응집도? 결합도?
   >
   > 응집도: 모듈이 하나의 목적을 수행하는데 요소간의 연관성 척도.
   >
   > - 모듈 내부의 기능적인 응집 정도
   > - 높을수록 좋다: 변경 대상과 범위가 명확해져 코드수정 용이
   >   ![응집도](https://user-images.githubusercontent.com/71415474/116351070-f60d6600-a82d-11eb-8161-2a693520dcfe.png)
   >
   > 결합도: 다른 모듈과의 의존 정도
   >
   > - 모듈과 모듈간 상호 결합 정도
   > - 낮을수록 Good: 결합도가 높으면 변경하고 검토해야되는 모듈 수가 많아짐
   >
   >   <img src="https://user-images.githubusercontent.com/71415474/116351100-01f92800-a82e-11eb-9d01-0e97fb7cd2e3.png" alt="결합도" style="zoom:50%;" />

   <br>

   그렇다면, **캡슐화는 어떻게 높은 응집도와 낮은 결합도를 갖게 할까?**

   바로 **정보 은닉**을 활용한다.

   외부에서 접근할 필요가 없는 것들은 private으로 접근하지 못하도록 제한을 두는 것이다.

   (객체안의 필드를 선언할 때 private으로 선언하라는 말이 바로 이 때문!!)

   <br>

3. ##### 상속

   > 일반화 관계(Generalization)라고도 하며, 여러 개체들이 지닌 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립하는 과정

   일반화(상속)은 또 다른 캡슐화다.

   **자식 클래스를 외부로부터 은닉하는 캡슐화의 일종**이라고 말할 수 있다.

   아까 자동차를 통해 예를 들어 추상화를 설명했었다. 여기에 추가로 대리 운전을 하는 사람 클래스가 있다고 생각해보자. 이때, 자동차의 자식 클래스에 해당하는 벤츠, BMW, 아우디 등은 캡슐화를 통해 은닉해둔 상태다.

   사람 클래스의 관점으로는, 구체적인 자동차의 종류가 숨겨져 있는 상태다. 대리 운전자 입장에서는 자동차의 종류가 어떤 것인지는 운전하는데 크게 중요하지 않다.

   새로운 자동차들이 추가된다고 해도, 사람 클래스는 영향을 받지 않는 것이 중요하다. 그러므로 캡슐화를 통해 사람 클래스 입장에서는 확인할 수 없도록 구현하는 것이다.

   이처럼, 상속 관계에서는 단순히 하나의 클래스 안에서 속성 및 연산들의 캡슐화에 한정되지 않는다. 즉, 자식 클래스 자체를 캡슐화하여 '사람 클래스'와 같은 외부에 은닉하는 것으로 확장되는 것이다.

   이처럼 자식 클래스를 캡슐화해두면, 외부에선 이러한 클래스들에 영향을 받지 않고 개발을 이어갈 수 있는 장점이 있다.

   <br>

   ##### 상속 재사용의 단점

   상속을 통한 재사용을 할 때 나타나는 단점도 존재한다.

   1. 상위 클래스(부모 클래스)의 변경이 어려워진다.

   > 부모 클래스에 의존하는 자식 클래스가 많을 때, 부모 클래스의 변경이 필요하다면?
   >
   > 이를 의존하는 자식 클래스들이 영향을 받게 된다.

   2. 불필요한 클래스가 증가할 수 있다.

   > 유사기능 확장시, 필요 이상의 불필요한 클래스를 만들어야 하는 상황이 발생할 수 있다.

   3. 상속이 잘못 사용될 수 있다.

   > 같은 종류가 아닌 클래스의 구현을 재사용하기 위해 상속을 받게 되면, 문제가 발생할 수 있다. 상속 받는 클래스가 부모 클래스와 IS-A 관계가 아닐 때 이에 해당한다.

   <br>

   ***해결책은?***

   객체 조립(Composition), 컴포지션이라고 부르기도 한다.

   객체 조립은, **필드에서 다른 객체를 참조하는 방식으로 구현**된다.

   상속에 비해 비교적 런타임 구조가 복잡해지고, 구현이 어려운 단점이 존재하지만 변경 시 유연함을 확보하는데 장점이 매우 크다.

   따라서 같은 종류가 아닌 클래스를 상속하고 싶을 때는 객체 조립을 우선적으로 적용하는 것이 좋다.

   ***그럼 상속은 언제 사용?***

   - IS-A 관계가 성립할 때
   - 재사용 관점이 아닌, 기능의 확장 관점일 때

   <br>

4. ##### 다형성(Polymorphism)

   > 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력

   객체 지향의 핵심과도 같은 부분이다.

   다형성은, 상속과 함께 활용할 때 큰 힘을 발휘한다. 이와 같은 구현은 코드를 간결하게 해주고, 유연함을 갖추게 해준다.

   즉, **부모 클래스의 메소드를 자식 클래스가 오버라이딩해서 자신의 역할에 맞게 활용하는 것이 다형성**이다.

   이처럼 다형성을 사용하면, 구체적으로 현재 어떤 클래스 객체가 참조되는 지는 무관하게 프로그래밍하는 것이 가능하다.

   상속 관계에 있으면, 새로운 자식 클래스가 추가되어도 부모 클래스의 함수를 참조해오면 되기 때문에 다른 클래스는 영향을 받지 않게 된다.
   
   <br>
#### 객체 지향 설계 과정

   - 제공해야 할 기능을 찾고 세분화한다. 그리고 그 기능을 알맞은 객체에 할당한다.
   - 기능을 구현하는데 필요한 데이터를 객체에 추가한다.
   - 그 데이터를 이용하는 기능을 넣는다.
   - 기능은 최대한 캡슐화하여 구현한다.
   - 객체 간에 어떻게 메소드 요청을 주고받을 지 결정한다.



---

### 면접 질문

1. **객체 지향 프로그래밍(OOP)이 뭐에요? **   
   프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법

   

2. **객체 지향 프로그래밍의 장, 단점 간단하게 설명해주세요.**

   \- **장점**
   
   - 코드 재사용이 용이  
   
   남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있음.
   
   - 유지보수가 쉬움  
   
   절차 지향 프로그래밍에서는 코드를 수정해야할 때 일일이 찾아 수정해야하는 반면 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 멤버 변수혹은 메서드로 있기 때문에 해당 부분만 수정하면 됨. 
   
   - 대형 프로젝트에 적합   
   
   클래스단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러명, 여러회사에서 개발이 필요할 시 업무 분담하기 쉽다.
   
   <br>
   
   \- **단점**
   
   - 처리속도가 상대적으로 느림
   
   - 객체가 많으면 용량이 커질 수 있음
   
   - 설계시 많은 시간과 노력이 필요
   
   <br>
   
3. **추상화가 무엇인가요?**  
   불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것

4. **캡슐화가 무엇인가요?**  
   기능과 특성의 모음을 "클래스"라는 "캡슐"에 분류해서 넣는것

5. **상속은 무엇인가요?**  
   **상속**은 부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게하고 기능의 일부분을 변경해야 할 경우 상속받은 자식클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것

6. **다형성은 무엇인가요? **   
   부모 클래스의 메소드를 자식 클래스가 오버라이딩해서 자신의 역할에 맞게 활용하는 것이 다형성

   

---

### Reference

- goto: https://m.blog.naver.com/PostView.nhn?blogId=birdparang&logNo=220270022132&proxyReferer=https:%2F%2Fwww.google.com%2F
- 장단점:https://taste-and-investment.tistory.com/entry/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%96%B8%EC%96%B4%EC%9D%98-%EC%9E%A5%EC%A0%90%EA%B3%BC-%EB%8B%A8%EC%A0%90-%EA%B0%9C%EB%85%90-%EC%A2%85%EB%A5%98-%EC%A0%88%EC%B0%A8%EC%A7%80%ED%96%A5-%EC%96%B8%EC%96%B4%EC%99%80-%EB%B9%84%EA%B5%90
- 얄팍한코딩사전-객체지향프로그래밍: https://www.youtube.com/watch?v=vrhIxBWSJ04