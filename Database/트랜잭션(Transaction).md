# 트랜잭션(Transaction)



### 트랜잭션(Transaction)

 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.



---

### 트랜잭션의 성질(ACID)

1. **Atomicity(원자성)**: 트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다.
2. **Consistency(일관성)**: 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야한다. 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전고 수행 완료 후에 같아야 한다.
3. **Isolation(격리성, 독립성)**: 둘 이상의 트랜잭션이 동시에 실행되고 있을 경우 어떤 하나의 트랜잭션이라도, 다른 트랜잭션의 연산에 끼어들 수 없다. 하나의 특정 트랜잭션이 완료될때까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다.
4. **Durability(지속성)**: 트랜잭션이 성공적으로 완료됐을 경우, 결과는 영구적으로 반영되어야 한다.

---

### 트랜잭션의 상태

<img src="https://user-images.githubusercontent.com/71415474/110240327-bdb87c80-7f8e-11eb-80b7-6c1e7fe426fe.png" alt="image-20210307180935374" style="zoom:67%;" />

1. **활동(Active)**: 트랜잭션이 실행중인 상태
2. **실패(Failed)**: 트랜잭션 실행에 오류가 발생하여 중단된 상태
3. **철회(Aborted)**: 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
4. **부분 완료(Partially Committed)**: 트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태
5. **Committed(완료)**: 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

---

### 트랜잭션 연산

1. **Commit**: 트랜잭션이 성공적으로 끝났고, DB가 일관성있는 상태에 있을 때, 하나의 트랜잭션이 끝났음 선언하는 연산. 트랜잭션이 수행한 결과를 실제 물리적 디스크에 저장한다.
2. **Rollback**: 트랜잭션 실행이 실패하였음을 선언하는 연산. 트랜잭션이 수행한 결과를 원래의 상태로 원상 복구시킨다.

---

### 회복

트랜잭션을 실행하는 도중에 **장애**가 발생하여 데이터베이스가 손상되었을 경우, 손상되기 이전의 정상 상태로 복구하는 작업



1. 장애의 유형

   - 실행장애: 응용 프로그램 내에 코드로 명시되어 있는 경우로서 ROLLBACK과 같은 연산의 명시로 인한 종료
   - 트랜잭션 장애: 계획되지 않은 비정상적 종료
     (데이터 잘못 입력, 데이터 부재, 오버플로우, 자원의 한계 초과, 0으로 나누는 연산)
   - 시스템 장애: CPU 고장, 소프트웨어 오류 등 하드웨어의 잘못된 작동으로 메인 메모리에 저장되어 있는 정보 손실
   - 미디어 장애: 저장장치에서 문제가 발생하여 DB와 관련된 모든 요소에 손상을 주는 장애

2. 중복 저장 기법

   - 덤프(Dump): DB를 복사본으로 다른 저장장치에 백업시켜놓는것
   - 로그 (Log): DB가 변경될 때마다 변경되는 데이터 항목의 이전 값과 이후 값을 별도로 기록
     - 로그 레코드의 유형
       <T1, Start> : 트랜잭션 T1의 실행이 시작됨
       <T1, X1, V1, V2> : 트랜잭션 T1이 데이터 항목 X1의 값을 V1에서 V2로 변경
       <T1, Commit> : 트랜잭션 T1의 실행이 완료됨

3. 회복의 원리: Redo, Undo 모두 로그를 이용하여 회복

   - **Redo(재수행)**: 장애가 발생하기 전에 트랜잭션이 **완료 명령을 수행(Commit)했을 경우**, 이 트랜잭션의 갱신 사항을 재수행하여 트랜잭션의 갱신이 영속성을 갖도록 해야 한다.

     <img src="https://user-images.githubusercontent.com/71415474/110240341-cdd05c00-7f8e-11eb-9b29-e2a4a2b4543d.png" alt="image-20210307184056610" style="zoom:67%;" />

   - **Undo(취소)**: 장애가 발생하기 전에 트랜잭션이 **완료 명령을 수행하지 못 했을 경우**, 원자성을 보장하기 위해서 트랜잭션이 데이터베이스에 반영했을 가능성이 있는 갱신 사항을 취소해야 한다. 

     <img src="https://user-images.githubusercontent.com/71415474/110240363-e50f4980-7f8e-11eb-9447-f1f2b162457c.png" alt="image-20210307183914993" style="zoom:67%;" />

     

4. 회복기법의 종류

   - **즉시 갱신(Immediate Update)**: 트랜잭션이 연상을 실행하고 있는 활동 상태에서 데이터의 변경 결과를 DB에 즉시 반영
   
      <img src="https://user-images.githubusercontent.com/71415474/110241034-0cb3e100-7f92-11eb-80bc-0f32bc9a6098.PNG" alt="1" style="zoom:50%;" />
   - **지연 갱신(Deferred Modification)**: 트랜잭션이 실행되는 동안 변경된 내용을 로그에 보관하다가 트랜잭션의 부분 완료 시점에 저장된 로그를 사용하여 변경 결과를 DB에 반영
   
      <img src="https://user-images.githubusercontent.com/71415474/110241050-26edbf00-7f92-11eb-9627-7b1ec5b8e6a4.PNG" alt="2" style="zoom:50%;" />
   - **검사시점(Check Point) 회복**:트랜잭션이 실행하는 동안 검사시점을 주기적으로 로그에 보관. 장애 발생 시 로그 내의 가장 최근의 검사시점으로부터 회복 작업을 수행
   
      <img src="https://user-images.githubusercontent.com/71415474/110241054-28b78280-7f92-11eb-9d6d-84f4064ede42.PNG" alt="3" style="zoom:50%;" />
   - **그림자 페이징(Shadow Paging)**: 트랜잭션이 실행되는 동안 로그를 사용하지 않고, DB를 일정 크기의 페이지와 복사본인 그림자 페이지로 보관한다.
      데이터 변경시 현 페이지 테이블만 변경하다가 장애를 회복할 시, 현 페이지 테이블을 그림자 페이지 테이블로 대체한다.

---

### 병행제어

 다수의 사용자가 데이터베이스에 요청을 보내게 되면 그 수많은 요청들을 병행으로 처리한다. 이 때, 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어하는 것을 **병행제어**라 한다.

- 병행성: 트랜잭션을 동시에 인터리빙(Interleaving)하게 실행
- 인터리빙(Interleaving): 트랜잭션이 번갈아가며 조금씩 처리



1. **병행 제어의 목적**

   - DB의 공유도 최대화
   - 시스템 활용도 최대화
   - 응답 시간 최소화
   - 단위 시간당 트랜잭션 처리 건수 최대화
   - DB의 일관성 유지

2. **병행 수행의 문제점**

   - **갱신 분실(Lost Update)**: 두 개 아상의 트랜잭션이 같은 자료를 공유하여 갱신할 때 갱신 결과의 일부가 없어지는 현상

     <img src="https://user-images.githubusercontent.com/71415474/110242230-7800b180-7f98-11eb-905b-5b230792b99a.PNG" alt="4" style="zoom: 67%;" />
   - **비완료 의존성(Uncommitted Dependency)**: 하나의 트랜잭션 수행이 실패한 후 회복되기 전에 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상. **(= Dirty Read)**

     <img src="https://user-images.githubusercontent.com/71415474/110242233-79ca7500-7f98-11eb-9209-b4d6ee8d694f.PNG" alt="5" style="zoom: 67%;" />
   - **모순성(Inconsistency)**: 두 개의 트랜잭션 수행이 끝났지만, 원치 않는 연산 결과가 나타나고 데이터베이스 자체도 모순된 상태로 남게 된 현상

     <img src="https://user-images.githubusercontent.com/71415474/110242236-7b943880-7f98-11eb-9915-ba5cf96a6df6.PNG" alt="6" style="zoom: 67%;" />
   - **연쇄 복귀(Cascading Rollback)**: 병행 수행되던 트랜잭션들의 하나에 문제가 생겨 Rollback하는 다른 트랜잭션도 함께 Rollback되는 현상

     <img src="https://user-images.githubusercontent.com/71415474/110242238-7cc56580-7f98-11eb-89ee-b91e1f0ed768.PNG" alt="7" style="zoom: 67%;" />

3. **병행제어 기법**

   - **로킹(Locking)-비관적제어**: 데이터의 액세스를 상호 배타적으로 만들어 병행을 제어하는 기법. 하나의 트랜잭션이 데이터를 액세스 하는 동안 다른 트랜잭션이 그 데이터 항목을 액세스할 수 없도록 한다.

     ![image-20210307191250530](https://user-images.githubusercontent.com/71415474/110240373-f0fb0b80-7f8e-11eb-96ae-d52b979e585b.png)

     - **2단계 로킹(2PL : Two-Phase Locking)**
       직렬성을 보장하는 대표적 잠금 기법. 잠금(Lock)과 잠금 해제(Unlock)를 아래의 2단계로 수행한다.

       - 성장(확장) 단계(Growing Phase): 객체를 사용하기 전에 잠금(Lock)
       - 축소 단계(Shrinking Phase): 잠금 해제(Unlock). 한 번 풀면 다시 잠그지 못함.

       이 방법을 따르는 트랜잭션들이 여러 개가 실행되면 직렬성이 높아지고, 잘못하면 교착상태에 빠질 수 있다. 

   - **타임스탬프(Time Stamp)-낙관적제어**: 트랜잭션이 시스템에 들어오는 순서대로 고유값을 부여. 트랜잭션의 실행 시작 시간을 나타냄



----

### 면접 질문

**Q. 트랜잭션이 뭔가요?**

A. 하나의 논리적 기능을 수행하기 위한 작업의 단위로, DB의 일관된 상태를 또 다른 일관된 상태로 변환시키는 기능을 수행한다.



**Q. 트랜잭션의 성질을 말씀해보세요.**

A. ACID라 불리는 총 네가지 성질을 가지고있습니다.

- Atomicity는 트랜잭션의 연산이 DB에 모두 반영되던지 전혀 반영이되지 않던지 둘중에 하나만 수행해야한다.(원자성)
- Consistency는 트랜잭션이 성공적으로 완료된 후에는 언제나 일관성 있는 DB상태로 변환되어야한다.(일관성)
- Isolation은 수행중인 트랜잭션이 완전히 완료되기 전에는 다른 트랙잭션에서 수행 결과를 참조할 수 없다.(독립성)
- Durablility는 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.(영속성)



**Q. 트랜잭션을 병행으로 처리하려고 할 때 발생할 수 있는 문제를 설명해보시오.**

- 갱신 내용 손실 : 동시에 하나의 데이터가 갱신될 때 하나의 갱신이 누락되는 경우
- 비완료 의존성 : 하나의 데이터 갱신이 끝나지 않은 시점에서 다른 트랜잭션이 해당 데이터를 조회하는 경우
- 모순성 : 두 트랜잭션이 동시에 실행될 때 데이터베이스가 일관성이 없는 모순된 상태로 남는 문제
- 연쇄 복귀 : 두 트랜잭션이 하나의 레코드를 갱신할 때 하나의 트랜잭션이 롤백하면 다른 하나의 트랜잭션 마저 롤백이 되는 문제



**Q. 트랜잭션을 병행으로 처리할 때 위와 같은 문제를 방지하기 위한 방법을 설명하시오.**

A. 로킹 제어 기법을 사용한다.

어떤 트랜잭션이 특정 DB의 데이터를 사용할 때 DB의 일정부분을 Lock시키고 트랜잭션이 완료될때 해당부분을 Unlock시키는 방법이다. 종류는 크게 두가지가 있는데 공유 로킹은 Lock한 부분을 읽기는 가능하지만 쓰기는 불가능한 것이고 배타 로킹은 읽기,쓰기 둘다 불가능하게 한 것이다.



**Q. 그렇다면 이 로킹 단위를 크게했을 때와 작게 했을 때의 차이점을 설명하시오.**

A. 로킹 단위가 크면 그만큼 관리가 쉽지만 병행성이 떨어진다. 로킹단위가 작으면 관리가 어렵고 오버헤드가 증가하지만, 병행성이 올라간다.



**Q. 로킹 제어가 일으킬 수 있는 문제점은 무엇인가?**

A. 로킹단위에 따라 다르겠지만 트랜잭션의 직렬화 가능성이 높아진다.(병행처리하나마나 할 수도있다.) 또 데드락이 발생할 수 있다.



**Q. COMMIT과 ROLLBACK에 대해 설명해보세요.**

A. COMMIT은 해당 트랜잭션으로 반영된 DB 변경사항을 **저장**, ROLLBACK은 해당 트랜잭션으로 반영된 DB 변경사항을 **취소**



**Q. 데이터베이스 장애의 유형**

- 실행장애: 응용 프로그램 내에 코드로 명시되어 있는 경우로서 ROLLBACK과 같은 연산의 명시로 인한 종료
- 트랜잭션 장애: 트랜잭션의 실행 시 논리적인 오류로 발생할 수 있는 에러 상황
- 시스템 장애: H/W 시스템 자체에서 발생할 수 있는 에러 상황
- 미디어 장애: 디스크 자체의 손상으로 발생할 수 있는 에러 상황



**Q. 데이터베이스 회복 기법에 대해 설명하시오.**

- 지연 갱신 회복 기법
  - write 연산 지연, 로그에 DB변경 내역 저장
  - 트랜잭션 완료시 로그를 보고 write 연산 수행
  - 트랜잭션 완료시 장애 발생 : REDO만 실행
  - 트랜잭션 미완료시 장애 발생 : 로그 무시
- 즉시 갱신 회복 기법
  - 즉시 DB 변경, 로그에 기록
  - 장애 발생 시 로그에 기반하여 UNDO 실행
- 체크포인트 회복기법
  
  - 체크 포인트를 지정하여 장애발생시 체크포인트까지 UNDO 실행 후 다시 REDO 실행
- 그림자 페이징 회복 기법
  - 하드디스크에 그림자 페이지를 만들고 저장해두고 장애발생시 하드디스크에 있는 페이지로 주메모리 페이지 변경
  - 장애 미발생시 그림자 페이지 테이블은 삭제
  
  

---

### Reference

- https://www.youtube.com/watch?v=q_KU7Ek_XA4