# 프로세스 VS 스레드

> **프로세스** : 실행 중인 프로그램으로 시스템 자원을 할당받아 메모리 상에서 실행중인 작업
>
> **스레드** : 프로세스 안에서 실행되는 여러 흐름 단위



기본적으로 프로세스마다 최소 1개의 스레드 소유 (메인 스레드 포함)



[![img](https://camo.githubusercontent.com/3dc4ad61f03160c310a855a4bd68a9f2a2c9a4c7/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f393938383931343635433637433330363036)](https://camo.githubusercontent.com/3dc4ad61f03160c310a855a4bd68a9f2a2c9a4c7/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f393938383931343635433637433330363036)

프로세스는 각각 별도의 주소공간 할당 (독립적)

- Code : 코드 자체를 구성하는 메모리 영역(프로그램 명령)
- Data : 전역변수, 정적변수, 배열 등
  - 초기화 된 데이터는 data 영역에 저장
  - 초기화 되지 않은 데이터는 bss 영역에 저장
- Heap : 동적 할당 시 사용 (new(), mallock() 등)
- Stack : 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)



스레드는 Stack만 따로 할당 받고 나머지 영역은 서로 공유



하나의 프로세스가 생성될 때, 기본적으로 하나의 스레드 같이 생성



**프로세스는 자신만의 고유 공간과 자원을 할당받아 사용**하는데 반해, **스레드는 다른 스레드와 공간, 자원을 공유하면서 사용**하는 차이가 존재함





##### 중앙처리장치(CPU)

인간으로 따지면 두뇌에 해당하는 부분

- 주기억장치에서 프로그램 명령어와 데이터를 읽어와 처리하고 명령어의 수행 순서를 제어.

- 비교와 연산을 담당하는 **산술논리연산장치(ALU)**와 명령어의 해석과 실행을 담당하는 **제어장치**, 속도가 빠른 데이터 기억장소인 **레지스터**로 구성.

개인용 컴퓨터와 같은 소형 컴퓨터에서는 CPU를 마이크로프로세서라고도 부름



하드디스크에 저장되어 있는 명령어와 데이터의 묶음 자체는 ''프로그램'', ''프로세스''는 그러한 프로그램을 실행하여 메모리 상에서 실행되는 작업단위



**CPU는 한번에 하나의 프로세스**만 관리





**프로세스 상태**

> 생성(create = new), 실행(running), 준비(ready), 대기(waiting), 종료(terminated) 

![os-3](https://user-images.githubusercontent.com/24764210/108018515-52e4e700-705b-11eb-907f-3cbdd3059b1a.jpg)

그림에서 다섯개의 파란색 동그라미가 각각 프로세스의 상태입니다.

**생성(create or new) 상태**란, 프로세스 자체는 생성되었지만 아직 프로그램이 메모리에 적재되지 않은 상태를 말합니다.

**준비(ready) 상태**란, 실행된 프로세스가 메모리에 적재되고 CPU를 할당 받기 위해서 준비중인 상태입니다.

**실행(running) 상태**란, 프로세스가 CPU를 할당받아서 명령어를 실행하고 있는 상태입니다.

**대기(waiting or Block) 상태**란, 실행상태에 있던 프로세스가 급작스런 이벤트에 의해 실행을 일시적으로 멈춘 상태를 말합니다.

**종료(terminated) 상태**란, 프로세스의 실행이 모두 정상적으로 끝나서 종료된 상태를 말합니다.



각각의 상태가 특정 이벤트에 의해 변화되는 것을 상태 전이라고 합니다.



**admitted**: 생성된 프로세스가 승인을 받아서 실행이 됩니다.

**scheduler dispatch**: 보통 dispatch라고도 말하며, 준비상태에 있던 프로세스가 CPU를 할당받아서 실행되는 것입니다.

**interrupt**: 실행 중이던 프로세스가 특정 이벤트에 의해서 다시 준비상태로 넘어가는 것입니다. 프로세스가 할당된 시간에 모든 명령을 실행하지 못하여 넘어가는 Time out 등이 있습니다.

**I/O or event wait**: CPU가 프로세스를 실행 중에 있을 때 급작스런 이벤트에 의해서 CPU가 다른 프로세스를 할당하게 될때 현재 실행중인 프로세스는 대기상태로 넘어가는데 이러한 상태전이를 말합니다.

**I/O or event completion**: 급작스런 이벤트에 의한 CPU할당을 받는 프로세스의 실행이 끝나면 대기상태에 있던 프로세스는 다시 준비상태로 넘어가게 됩니다. 이러한 상태 전이를 말합니다.

**exit**: 프로세스의 모든 명령이 실행되고 종료되는 상황을 말합니다.



예를 들어, 게임에 로그인을 한다고 가정하면 아이디와 패스워드를 입력하기 전까지는 waiting 상태이고, 아이디와 패스워드 입력은 완료하고 로그인을 실행하는 것이 ready 상태, 게임에 접속되어 플레이되는 것을 running 상태라고 볼 수 있다.





##### 멀티프로세스

> 하나의 컴퓨터에 여러 CPU 장착 → 하나 이상의 프로세스들을 동시에 처리(병렬)

**장점** : 안전성 (독립된 구조이기 때문에 메모리 침범 문제를 OS 차원에서 해결)

**단점** : 각각 독립된 메모리 영역을 갖고 있어, 작업량 많을 수록 오버헤드 발생. Context Switching으로 인한 성능 저하



***Context Switching(문맥교환)\*이란?**

> 하나의 사용자 프로세스로부터 **다른 사용자 프로세스로** CPU의 제어권이 이양되는 과정
>
> 프로세스의 상태 정보를 저장하고 복원하는 일련의 과정
>
> 즉, 동작 중인 프로세스가 대기하면서 해당 프로세스의 상태를 PCB에 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 보관했던 프로세스 상태를 복구하는 과정을 말함
>
> → 프로세스는 각 독립된 메모리 영역을 할당받아 사용되므로, 캐시 메모리 초기화와 같은 무거운 작업이 진행되었을 때 오버헤드가 발생할 문제가 존재함
>
> 오버헤드 : 실행시간이나 필요한 메모리 외에 발생하는 시간이나 메모리. 문맥교환에 필요한 시간, 메모리도 오버헤드라고 한다.





##### 멀티 스레드

> 하나의 응용 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리하는 것

스레드들이 공유 메모리를 통해 다수의 작업을 동시에 처리하도록 해줌



**장점** : 적은 메모리 공간을 차지하고 문맥 전환이 빠름. 독립적인 프로세스에 비해 공유 메모리만큼의 시간, 자원 손실이 감소. 전역 변수와 정적 변수에 대한 자료 공유 가능.

**단점** : 안전성 문제. 하나의 스레드가 데이터 공간 망가뜨리면, 모든 스레드가 작동 불능 상태 (공유 메모리를 갖기 때문)

- 멀티스레드의 안전성에 대한 단점은 Critical Section(임계영역) 기법을 통해 대비함

  > 하나의 스레드가 공유 데이터 값을 변경하는 시점에 다른 스레드가 그 값을 읽으려할 때 발생하는 문제를 해결하기 위한 동기화 과정
  >
  > 둘 이상의 스레드가 동시에 접근해서는 안 되는 공유자원의 독점을 보장하는 코드 영역
  > ```
  > 상호 배제, 진행, 한정된 대기를 충족해야함
  > ```
  >
  > - 동기화 : 프로세스 또는 스레드들이 수행되는 시점을 조절하는 것





[자료 출처]

https://devuna.tistory.com/21

https://doorbw.tistory.com/26