# 인터럽트(Interrupt)

프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황을 우선 처리한 후 실행 중이던 작업으로 복귀하여 계속 처리하는 일련의 과정

<br>

컴퓨터에 설정된 장치에서 프로세서로 보내는 하드웨어 신호

<br>

지금 수행 중인 일보다 더 중요한 일(ex. 입출력, 우선 순위 연산 등)이 발생하면 그 일을 먼저 처리하고 나서 하던 일을 계속해야한다.

<br>

외부/내부 인터럽트는 `CPU의 하드웨어 신호에 의해 발생`

소프트웨어 인터럽트는 `명령어의 수행에 의해 발생`

- ##### 외부 인터럽트

  입출력 장치, 타이밍 장치, 전원 등 외부적인 요인으로 발생

  `전원 이상(정전), 기계 착오(CPU의 기능적인 오류), 외부 신호(), 입출력`

  - 전원 이상 : 정전 or 전원 이상 등
  - 기계 착오 : CPU의 기능적인 오류 동작 등
  - 외부 신호 : 타이머에 의해 규정된 시간을 알리는 경우, 키보드로 인터럽트 키를 누른 경우 등
  - 입출력 : 입출력 data의 오류, 입출력장치가 데이터의 전송을 요구하거나 전송이 끝났을을 알릴 경우 등

- ##### 내부 인터럽트

  Trap이라고 부르며, 잘못된 명령이나 데이터를 사용할 때 발생

  > 0으로 나누기가 발생, 오버플로우, 명령어를 잘못 사용한 경우 (Exception)

  <img src="https://user-images.githubusercontent.com/24764210/112316105-22ddd300-8cee-11eb-9c88-ab873f984727.png" alt="image" style="zoom:50%;" />

- ##### 소프트웨어 인터럽트

  프로그램 처리 중 명령의 요청에 의해 발생한 것 (SVC 인터럽트)

  소프트웨어가 스스로 인터럽트를 발생시키는 것

  > 사용자가 프로그램을 실행시킬 때 발생
  >
  > 소프트웨어 이용 중에 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당 동작이 수행된다.
  >
  
  - system call :  응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스. C나 C++과 같은 고급 언어로 작성된 프로그램들이 직접 시스템 호출을 사용할 수 있도록 고급 API를 통해 시스템 호출에 접근하게 하는 방법이다.
  
    -  시스템 콜의 종류
  
      - 프로세스 컨트롤
        - 프로세스 생성 및 종료
        - 메모리에 로드, 실행
        - 프로세스 속성 값 확인, 지정
        - wait 이벤트, signal 이벤트
        - 메로리 할당
      - 파일 메니지먼트
        - 파일 생성, 파일 삭제
        - 열기, 닫기
        - 읽기, 쓰기, Reposition
        - 파일 속성 값 확인, 지정
      - 디바이스 매니지먼트
        - 디바이스 요청 및 해제
        - 읽기, 쓰기, Reposition
        - 디바이스 속성 확인, 지정
        - 비 물리적인 디바이스 해제 및 장착
      - 정보 관리
        - 시간 확인, 시간 지정
        - 시스템 데이터 확인, 지정
        - 프로세스, 파일, 디바이스 속성 가져오기
        - 프로세스, 파일, 디바이스 속성 설정하기
  
      - 커뮤니케이션
        - 커뮤니케이션 연결 생성 및 삭제
        - 메시지 송신, 수신
        - 상태 정보 전달
        - remote 디바이스 해제 및 장착
      - 보안
        - Permission 획득
        - Permission 설정

- SVC 인터럽트 : 프로세서에게 컴퓨터 제어권을 수퍼바이저(OS) 프로그램에 넘길 것을 지시하는 프로세서명령어

<br>

<br>

#### 인터럽트 작동 방식

<img src="https://user-images.githubusercontent.com/24764210/111190644-a31f7c80-85fa-11eb-82c0-5e2c17cb53ba.PNG" alt="a" style="zoom:67%;" />

인터럽트가 명령어 주소 i인 곳에서 발생했다면 명령어 i+1의 주소를 PCB에 저장한다.

복귀주소는 스택에 저장.

<br>

<br>

#### 인터럽트 발생 처리 과정

<img src="https://user-images.githubusercontent.com/24764210/111192405-59d02c80-85fc-11eb-9d6c-d29cc5990749.PNG" alt="jhg" style="zoom:80%;" />

(a) : 프로그램 A가 실행되고 있고 PC에는 현재 명령어를 가르키고 있는 상태

(b) : 프로세서에 인터럽트 신호가 도달하면 현재 명령어는 종료. 모든 레지스터의 내용은 스택 영역안에 PCB에 저장. PC에는 인터럽트 시작 위치인 프로그램 B를 저장하고 제어를 넘겨 B를 실행.

(c) : 인터럽트를 종료하면 스택 영역에 있던 내용을 레지스터에 다시 저장. 중단했던 프로그램 A를 재시작.

<br>

![os-4](https://user-images.githubusercontent.com/24764210/108018517-52e4e700-705b-11eb-8569-51e516390607.png)

주 프로그램이 실행되다가 인터럽트가 발생했다.

1. 인터럽트 요청
2. 프로그램 실행 중단
3. 현재의 프로그램 상태 보존 : PCB(Process Control Block)에 PC(Program Counter)와 SR(Status Register)를 저장 (인터럽트 서비스 루틴이 끝난 뒤 다시 원래 작업으로 돌아와야 하기 때문)
4. 인터럽트 처리루틴 실행 : 인터럽트를 요청한 장치를 식별한다.
5. 인터럽트 서비스 루틴 실행 : 인터럽트 원인을 파악하고 인터럽트를 처리한다. 처리기 레지스터 상태를 보존한다. 서비스 루틴 수행 중 우선순위가 더 높은 인터럽트가 발생하면 또 재귀적으로 1~5를 수행한다.
6. 상태복구 : 인터럽트 발생 시 저장해둔 PC(Program counter)를 다시 복구한다.
7. 중단된 프로그램 실행 재개 : PC의 값을 이용하여 이전에 수행중이던 프로그램을 재개한다.

<br>

만약 **인터럽트 기능이 없었다면**, 컨트롤러는 특정한 어떤 일을 할 시기를 알기 위해 계속 체크를 해야 한다. (이를 **폴링(Polling)**이라고 한다)

폴링을 하는 시간에는 원래 하던 일에 집중할 수가 없게 되어 많은 기능을 제대로 수행하지 못하는 단점이 있었다.

<br>

### 인터럽트 우선순위 판별방법

- ##### 폴링 방식 (소프트웨어적인 방법)

  인터럽트 발생 시 인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 찾아 이에 맞는 인터럽트 서비스 루틴을 수행한다. 

  **장점** : 우선순위 변경이 쉽고 회로가 간단

  **단점** : 많은 인터럽트가 있을 경우 하드웨어적인 방법에 비해 반응시간이 느려 우선순위 판단 속도가 느림

<br>

- ##### 인터럽트 방식 (하드웨어적인 방법) = 벡터 인터럽트(Vector Interrupt)

  MCU 자체가 하드웨적으로 변화를 체크하여 변화 시에만 일정한 동작을 하는 방식 

  **장점** : 프로세서가 이벤트 발생 여부를 감시(Polling)할 필요가 없음

  **단점** : 회로가 복잡하고 하드웨어가 필요하다.

  직렬과 병렬 우선순위 부여 방식이 있다.

  - Daisy Chain (직렬방식) : 인터럽트가 발생하는 모든 장치를 하나의 직렬 회선으로 연결한다.

    우선순위가 높은 장치를 상위에 두고 우선순위 차례대로 배치한다.

  <br>

  - 병렬 우선순위 부여 방식 : 각 장치마다 별개의 회선으로 연결하고 인터럽트 요청을 제어하기 위해 Mask Register를 사용한다.

    <br>
  
  `MCU (=마이크로 컨트롤러) ` : 마이크로 프로세서(CPU) + 입출력 모듈을 하나의 칩으로 만들어 놓은 것

인터럽트 방식은 하드웨어로 지원을 받아야 하는 제약이 있지만, 폴링에 비해 신속하게 대응하는 것이 가능하다. 따라서 **'실시간 대응'**이 필요할 때는 필수적인 기능이다.

<br>

<br>

<br>

### Q. 면접 질문

#### 인터럽트 처리과정을 말해보세요

인터럽트가 발생하면 프로그램을 중단하고 
현재의 프로그램 상태를 PCB에 보관하고 
인터럽트를 요청한 장치를 식별한 후 
인터럽트 서비스 루틴을 실행해서 인터럽트의 원인을 파악하고 처리기 레지스터에 상태를 보존하고 
우선순위가 높은 인터럽트를 먼저 처리하는데 서비스 루틴 수행 중 우선순위가 더 높은 인터럽트가 발생하면 앞서 말한 것들을 재귀적으로 다시 수행한다.
인터럽트가 끝나면 저장해둔 PC를 다시 복구하고 중단되었던 프로그램을 다시 실행한다.

<br>

<br>

<br>

[자료 출처]

https://coding-factory.tistory.com/353

https://raisonde.tistory.com/entry/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8Interrupt%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%A2%85%EB%A5%98