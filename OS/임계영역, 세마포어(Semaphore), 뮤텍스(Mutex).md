## 세마포어(Semaphore) & 뮤텍스(Mutex)



공유된 자원에 여러 프로세스가 동시에 접근하면서 문제가 발생할 수 있다. 이때 공유된 자원의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 둬야 한다.

이를 위해 나온 것이 바로 **'세마포어'**



##### 임계 구역(Critical Section)

> 여러 프로세스가 데이터를 공유하며 수행될 때, **각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분**

공유 데이터를 여러 프로세스가 동시에 접근할 때 잘못된 결과를 만들 수 있기 때문에, 한 프로세스가 임계 구역을 수행할 때는 다른 프로세스가 접근하지 못하도록 해야 한다.



### 세마포어

- 운영체제 또는 프로그램 작성 내에서 공유 자원에 세마포어의 변수만큼의 프로세스(또는 스레드)가 접근할 수 있도록 하는 방법(신호)이다.
- 공유자원에 접근 할 수 있는 최대 허용치만큼만 동시에 사용자 접근이 가능하다. 
- 쓰레드들은 리소스 접근 요청을 할 수 있고 세마포어에서는 카운트가 하나씩 줄어들게 되며 리소스가 모두 사용중인 경우(카운트 0) 다음 작업은 대기를 하게 된다.



#### 세마포어 P, V 연산

P : 임계 구역 들어가기 전에 수행 ( 프로세스 진입 여부를 자원의 개수(S)를 통해 결정) = Wait 함수

V : 임계 구역에서 나올 때 수행 ( 자원 반납 알림, 대기 중인 프로세스를 깨우는 신호 ) = Signal 함수



##### 구현 방법

```
P(S);

// --- 임계 구역 ---

V(S);
```



```
procedure P(S)   --> 최초 S값은 1임
    while S=0 do wait  --> S가 0면 1이 될때까지 기다려야 함
    S := S-1   --> S를 0로 만들어 다른 프로세스가 들어 오지 못하도록 함
end P

--- 임계 구역 ---

procedure V(S) --> 현재상태는 S가 0임
    S := S+1   --> S를 1로 원위치시켜 해제하는 과정
end V
```

이를 통해, 한 프로세스가 P 혹은 V를 수행하고 있는 동안 프로세스가 인터럽트 당하지 않게 된다. P와 V를 사용하여 임계 구역에 대한 상호배제 구현이 가능하게 되었다.

***예시***

> 최초 S 값은 1이고, 현재 해당 구역을 수행할 프로세스 A, B가 있다고 가정하자

1. 먼저 도착한 A가 P(S)를 실행하여 S를 0으로 만들고 임계구역에 들어감
2. 그 뒤에 도착한 B가 P(S)를 실행하지만 S가 0이므로 대기 상태
3. A가 임계구역 수행을 마치고 V(S)를 실행하면 S는 다시 1이 됨
4. B는 이제 P(S)에서 while문을 빠져나올 수 있고, 임계구역으로 들어가 수행함





**뮤텍스** : 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술

> 상호 배제(**Mut**ual **Ex**clusion)의 약자임

- 공유자원에 오직 1개만의 프로세스(또는 쓰레드)만 접근하기 때문에 해당 섹션에 접근하려는 다른 쓰레드들을 강제적으로 막음으로써 첫번째 쓰레드가 해당 섹션을 빠져나올 때 까지 기다린다. 
- 대기열(큐) 구조라고 생각하면 된다.



해당 접근을 조율하기 위해 lock과 unlock을 사용한다.

- lock : 현재 임계 구역에 들어갈 권한을 얻어옴 ( 만약 다른 프로세스/스레드가 임계 구역 수행 중이면 종료할 때까지 대기 )
- unlock : 현재 임계 구역을 모두 사용했음을 알림. ( 대기 중인 다른 프로세스/스레드가 임계 구역에 진입할 수 있음 )



뮤텍스는 상태가 0, 1로 **이진 세마포어**로 부르기도 함



#### **뮤텍스 알고리즘**

1. ##### 데커(Dekker) 알고리즘

   flag와 turn 변수를 통해 임계 구역에 들어갈 프로세스/스레드를 결정하는 방식

   - flag : 프로세스 중 누가 임계영역에 진입할 것인지 나타내는 변수
   - turn : 누가 임계구역에 들어갈 차례인지 나타내는 변수

   ```c
   while(true) {
       flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
       while(flag[j]) { // 프로세스 j가 현재 임계 구역에 있는지 확인
           if(turn == j) { // j가 임계 구역 사용 중이면
               flag[i] = false; // 프로세스 i 진입 취소
               while(turn == j) // turn이 j에서 변경될 때까지 대기
               	flag[i] = true; // j turn이 끝나면 다시 진입 시도
           }
       }
   }
   
   // ------- 임계 구역 ---------
   
   turn = j; // 임계 구역 사용 끝나면 turn을 넘김
   flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
   ```
   ```c
   bloolean flag[2];
   int turn;
   void P0() {
       while (true){
           flag[0] = true;
           while (flag[1]) {
               if (turn == 1) {
                   flag[0] = false;
                   while (turn == 1) /* do nothing */;
                       flag[0] = true;
               }
           }
           
   		/* critical section */;
           
           turn = 1;
           flag[0] = false'
           /* remainder */
       }
   }
   
   
   void P1() {
   
       while (true){
           flag[1] = true;
           while (flag[0]) {
               if (turn == 0) {
                   flag[1] = false;
                   while (turn == 0) /* do nothing */;
                       flag[1] = true;
               }
           }
       
           /* critical section */;
       
           turn = 0;
           flag[1] = false
           /* remainder */
       }
   }
   void main() {
       flag[0] = false;
       flag[1] = false;
       turn = 1
       parbegin (P0, P1); // 스레드 동작방식 유사
   }
   ```


2. ##### 피터슨(Peterson) 알고리즘

   데커와 유사하지만, 상대방 프로세스/스레드에게 진입 기회를 양보하는 것에 차이가 있음

   ```c
   while(true) {
       flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
       turn = j; // 다른 프로세스에게 진입 기회 양보
       while(flag[j] && turn == j) { // 다른 프로세스가 진입 시도하면 대기
       }
   }
   
   // ------- 임계 구역 ---------
   
   flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
   ```
   ```c
   #include <iostream>
   #include <thread>
    
   using namespace std;
    
   int cnt;
   bool flag[2] = { false, false };
   int turn = 0;
    
   void func0() {
       for (int i = 0; i < 10000; i++) {
           flag[0] = true;
           turn = 1;
           while (flag[1] == true && turn == 1) {}
    
           cnt++;
           printf("cnt1 :: %d\n", cnt);
    
           flag[0] = false;
       }
   }
   void func1() {
       for (int i = 0; i < 10000; i++) {
           flag[1] = true;
           turn = 0;
           while (flag[0] == true && turn == 0) {}
    
           cnt++;
           printf("cnt2 :: %d\n", cnt);
    
           flag[1] = false;
       }
   }
    
   int main() {
       thread t1(func0);
       thread t2(func1);
    
       t1.join();
       t2.join();
    
       cout << "cnt : :" << cnt << endl;
    
       return 0;
   }
   ```


3. ##### 제과점(Bakery) 알고리즘

   여러 프로세스/스레드에 대한 처리가 가능한 알고리즘. 가장 작은 수의 번호표를 가지고 있는 프로세스가 임계 구역에 진입한다.

   ```c
   while(true) {
       
       isReady[i] = true; // 번호표 받을 준비
       number[i] = max(number[0~n-1]) + 1; // 현재 실행 중인 프로세스 중에 가장 큰 번호 배정 
       isReady[i] = false; // 번호표 수령 완료
       
       for(j = 0; j < n; j++) { // 모든 프로세스 번호표 비교
           while(isReady[j]); // 비교 프로세스가 번호표 받을 때까지 대기
           while(number[j] && number[j] < number[i] && j < i);
           
           // 프로세스 j가 번호표 가지고 있어야 함
           // 프로세스 j의 번호표 < 프로세스 i의 번호표
       }
   }
   
   // ------- 임계 구역 ---------
   
   number[i] = 0; // 임계 구역 사용 종료
   ```







## 뮤텍스와 세마포어를 설명하고 둘의 차이점을 설명하시오.

- 세마포어(Semaphore)
  - 운영체제 또는 프로그램 작성 내에서 공유 자원에 세마포어의 변수만큼의 프로세스(또는 스레드)가 접근할 수 있도록 하는 방법(신호)이다.
  - 공유자원에 접근 할 수 있는 최대 허용치만큼만 동시에 사용자 접근이 가능하다. 
  - 쓰레드들은 리소스 접근 요청을 할 수 있고 세마포어에서는 카운트가 하나씩 줄어들게 되며 리소스가 모두 사용중인 경우(카운트 0) 다음 작업은 대기를 하게 된다.
- 뮤텍스(Mutex)
  - 공유자원에 오직 1개만의 프로세스(또는 쓰레드)만 접근하기 때문에 해당 섹션에 접근하려는 다른 쓰레드들을 강제적으로 막음으로써 첫번째 쓰레드가 해당 섹션을 빠져나올 때 까지 기다린다. 
  - 대기열(큐) 구조라고 생각하면 된다.
- 차이점
  - 세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없다. 
  - 동기화 대상의 갯수가 다르다. **뮤텍스는 동기화 대상이 오직 하나뿐일 때, 세마포어는 동기화 대상이 하나 이상일 때 사용한다.**



**상호배제** : 공유 자원을 어느 시점에서 단지 한 개의 프로세스만이 사용할 수 있도록 하며, 다른 프로세스가 공유자원에 대하여 접근하지 못하게 제어하고 각 프로세스가 번갈아 가며 공유 자원을 사용하도록 하는 것으로 임계 구역을 유지하는 기법

**동기화** : 각 프로세스에 대한 처리 순서를 결정하는 것으로 상호 배제의 한 형태