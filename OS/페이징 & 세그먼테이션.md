# 페이징 & 세그먼테이션



#### 메모리(= 주소 공간) 해석에 대한 두 가지 관점

물리적 공간(= 물리적 메모리) : 실제 데이터나 프로그램이 저장되는 공간  ex) 주기억장치, 디스크, 0x00000008

논리적 공간(= 논리적 메모리) : 프로그래머가 프로그래밍에 사용하는 공간  ex) 배열같은 자료구조, arr[100]

<img src="https://user-images.githubusercontent.com/24764210/115153204-b321f480-a0af-11eb-9f07-0af4a2edff86.png" alt="992A37385A8AC5B240" style="zoom:80%;" />

- **mapping** 

  > 논리적 주소와 물리적 주소의 연결. 가상메모리에 프로그램이 실행될 경우 어떤 과정을 통해 실제 메모리로 옮겨 지게 되는데 이를 mapping이라고 한다.
  >
  > 현재 mapping은 mmu(=메모리 관리 장치)라는 하드웨어에 의해 지원되고 있다.

<br>

<br>

#### 메모리 관리 방식(기법)

> 프로세스를 메인 메모리(주기억 장치)에 적재하는 방식

- 연속 메모리 할당

  `고정 분할`, `동적 분할(= 가변 분할)` 

- 분할 메모리 할당 

  `페이징`, `세그먼트`, `페이지화된 세그먼트` 
  
	<br>

	**메모리 기법을 쓰는 이유**
	
	> 다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 작업이 필요해서

<img src="https://user-images.githubusercontent.com/24764210/115152853-ec596500-a0ad-11eb-8b39-3ca232fef41a.PNG" alt="SSSSS" style="zoom: 80%;" />

- 가상메모리

  > 보조기억장치의 일부로 주기억장치 안의 프로그램 양이 많아질 때, 사용하지 않는 프로그램을 보조기억장치 안의 특별한 영역으로 옮겨서, 그 보조기억장치 부분을 주기억장치처럼 사용할 수 있다.

​         <br>   <br>

<br>

<br>

#### 메모리 관리 기법

- Overlay(중첩) : 프로그램의 메모리가 주기억장치보다 클 때, 하나의 프로그램을 여러 개의 조각으로 분할한 후 필요한 조각을 순서대로 주기억장치에 적재하여 프로그램을 실행하는데, 실행 중에 주기억장치의 메모리가 부족하면 불필요한 조각(당장 필요하지 않는 프로그램)이 있는 곳에 새로운 조각을 중첩하여 적재

  <br>

1. 연속 메모리 관리

   > 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당

   - **고정 분할 기법** : 주기억장치가 고정된 파티션으로 분할 (**내부 단편화, 외부단편화 발생**)

     <img src="https://user-images.githubusercontent.com/24764210/115146194-70045900-a090-11eb-9d9f-fa0759c00fc0.PNG" alt="고정할당" style="zoom:80%;" />

   - **동적 분할 기법** : 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재 (**외부 단편화 발생**)

     <img src="https://user-images.githubusercontent.com/24764210/115146211-7e527500-a090-11eb-9e4c-1465f8e5166a.PNG" alt="동적할당" style="zoom:80%;" />
     
     - 메모리 배치 기법 (**요구된 크기 n을 사용가능공간에 어떻게 동적으로 할당할 것인지**)
     
       - **최초 적합** : 사용가능공간 리스트에서 충분히 큰 첫 번째 공백 분할 공간에 할당.
     
         ![KakaoTalk_20210418_220329139_02](https://user-images.githubusercontent.com/24764210/115146882-7811c800-a093-11eb-9dfa-98a2267bfad3.jpg)
     
       - **최상 적합** : 프로세스가 들어갈 수 있는 충분히 큰 사용가능공간 중에서 가장 작은 크기의 사용 공간에 작업을 할당. 공간 리스트가 크기 순서로 정렬되어 있지 않으면 전 리스트를 검색해야해서 정렬과정으로 인해 비효율적일 수 있다.
     
         ![KakaoTalk_20210418_220329139_01](https://user-images.githubusercontent.com/24764210/115146880-76e09b00-a093-11eb-8392-13dbb9971eba.jpg)
     
       - **최악 적합** : 작업을 가장 큰 사용가능공간에 할당. 공간 리스트가 크기 순서로 정렬되어 있지 않으면 전 리스트를 검색해야해서 정렬과정으로 인해 비효율적일 수 있다.
     
         ![KakaoTalk_20210418_220329139](https://user-images.githubusercontent.com/24764210/115146881-77793180-a093-11eb-9211-63461a133693.jpg)
     
       - 효율성 : **최초 > 최상 > 최악**
     
       - 외부 단편화 해결방안 2가지
     
         - 통합 : 비어 있는 다른 기억 장소(공백)와 인접되어 있는지를 점검하며 하나의 공백으로 합하는 과정
     
           ![KakaoTalk_20210418_222025502_01](https://user-images.githubusercontent.com/24764210/115147163-a80d9b00-a094-11eb-80d2-16ead1b444d1.jpg)
     
         - 압축 : 배치된 메모리들을 주소 재배치를 통해 한쪽으로 밀어서 남은 공간을 합하는 만드는 과정
     
           ![KakaoTalk_20210418_222025502](https://user-images.githubusercontent.com/24764210/115147165-a8a63180-a094-11eb-8ff3-d2a368aa7858.jpg)

<br>

<br>


2. 불연속 메모리 관리

   > 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법

   - **페이징(Paging)** : 메인메모리를 프레임(페이지 프레임)이라 불리는 **고정 크기 블록으로** 나누고 각 프로세스도 페이지라 불리는 동일한 크기의 작고 고정된 크기의 영역으로 분할한 후 한 작업의 페이지가 메모리의 여러 위치에 **분산 적재**.

     > - 프레임 크기 = 페이지 크기
     >
     > - 외부 단편화 X
     >
     > - 소량의 내부 단편화 존재 : 
     >
     > ​		프레임 크기가 4k이고 A 프로그램의 크기가 53k일 때, 마지막 페이지 크기는 1k가 될 수 있음.
     >
     > - 페이지 크기가 작을수록, 더 많은 페이지 사상표가 필요 / 내부단편화 감소 / 페이지부재 증가 / 페이지 집합(Working Set, 많이 사용되는 프로세스 집합)을 효율적으로 운영
     > - 페이지 폴트가 일어나면 페이지를 칮이서 주기억장치에 적재

     <img src="https://user-images.githubusercontent.com/24764210/115149020-135b6b00-a09d-11eb-9117-928def961bb8.PNG" alt="페이징" style="zoom:80%;" />

     ​										--**<i>설명을 위해 주기억장치의 메모리를 연달아 그렸으나 분산된 형태가 맞음</i>**--

     

   ** **프레임(Frame):** 물리 메모리를 사용하는 최소 크기 단위.

   ** **페이지(Page):** 가상 메모리를 사용하는 최소 크기 단위.

   <br>

   - **세그먼테이션(Segmentation)** : 프로세스를 **논리적 내용을 기반**으로 나눠서 메모리에 배치하는 것

     > 주기억장치 전체를 비연속적으로 할당받아 사용
     >
     > 내부단편화 X, 외부 단편화 O
     >
     > Protection Key(기억장치 보호키) : 메모리에 올라온 프로세스가 무엇인지 구분하기 위한 꼬리표
     >
     > 세그먼트는 연결된 기억장소로 구성되기 때문에 불필요한 부분이 들어가지 않아 메모리를 효율적으로 관리
     >
     > 교체시간이 길어짐
     >
     > 주기적으로 '압축'이 필요

     <img src="https://user-images.githubusercontent.com/24764210/115152272-6dfbc380-a0ab-11eb-9b91-c37f124da356.PNG" alt="ㅁㅇㅁㅇㄴ" style="zoom: 67%;" />

     <img src="https://user-images.githubusercontent.com/24764210/115151313-515d8c80-a0a7-11eb-9558-a9361c30d012.PNG" alt="세그먼트" style="zoom:80%;" />

   <br>

   <br>

   - **페이지화된 세그먼트** : 세그먼트를 페이징한 것

     > 외부 단편화 제거

     <img src="https://user-images.githubusercontent.com/24764210/115151912-f4afa100-a0a9-11eb-99c8-1d945ecbe575.PNG" alt="페이지화된 세그먼트" style="zoom:80%;" />

<br>

<br>

<br>

### Q. 면접 질문

#### 페이징과 세그먼테이션에 대해 설명하시오.

`페이징 기법`은 메인메모리를 프레임(페이지 프레임)이라 불리는 **고정 크기 블록으로** 나누고 각 프로세스도 페이지라 불리는 동일한 크기의 작고 고정된 크기의 영역으로 분할한 후 한 작업의 페이지가 메모리의 여러 위치에 **분산 적재**하는 기법이다. 페이징 기법을 사용하면 연속적이지 않은 공간을 활용할 수 있기 때문에 **외부단편화를을 해결**할 수 있습니다. 그리고 **페이지 단위를 작게하면 내부 단편화를 해결**할 수 있지만 **많은 페이지 사상표가 필요**하게 되고 **페이지 부재가 자주 일어나** 오버헤드가 커집니다.

<br>`세그먼테이션 기법`으 프로세스를 **논리적 내용을 기반**으로 나눠서 메모리에 배치하는 것으로 주기억장치 전체를 **비연속적으로 할당받아** 사용하는 기법입니다. 내부단편화는 없지만 **외부 단편화가 발생**할 수 있기 때문에 주기적인 **압축**이 필요합니다. 세그먼트는 연결된 기억장소로 구성되기 때문에 불필요한 부분이 들어가지 않아 메모리를 효율적으로 관리할 수 있습니다. 

<br>

<br>

#### 가상 메모리란

보조기억장치의 일부로 **주기억장치 안의 프로그램 양이 많아질 때**, 사용하지 않는 프로그램을 보조기억장치 안의 특별한 영역으로 옮겨서, 그 **보조기억장치 부분을 주기억장치처럼 사용하는 메모리**이다. 즉, **프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법**을 가상메모리라 한다.